Extract Function (from Statement Sequence)

User Input:
	1. A selection consisting of a sequence of one or more statements in a BlockStmt
	2. A name, f, for the extracted function

Preconditions:

	Compute the following sets of local variables:
		R: Def-use entering the selected region
		W: Def-use exiting the selected region
		I: Def-use within the selected region
		L: Declared in the selected region
		A: Address is taken (&v) within the selected region or before it (w.r.t. control flow)

	1. The selected statements must form a basic block.
	2. The first statement in the block must not be a labeled statement.
	3. The last statement in the block must not be a return, break, continue, goto, or fallthrough statement.
	4. The new function name f must be a valid Go identifier.
	5. There must not be an object named f in the scope of the first selected statement.
	6. (R ∪ W) ∩ A = ∅.  See Notes below.

Transformation:
	1. Add a new top-level function f, initially empty, with
		Parameters: R
		Return types: same as variables in W
	2. Construct the body of f, consisting of:
		- Local variable declarations for the variables in (I ∪ W) - R - L
		- The selected statements
		- A return statement returning the values of the variables in W
	3. If L ∩ W ≠ ∅, replace the statements with the single assignment statement
		W := f(R)
	    and otherwise, replace them with
		W = f(R).

Notes:

	- Preconditions 1, 2, and 3 can be made less strict if the transformation is adjusted to handle more complex control flows correctly (e.g., replacing the statement sequence with "return extractedFunction()").

	- Precondition 6 is justified as follows.  The locals in R will be passed as parameters of the extracted function, and the locals in W will be declared as local variables or parameters in the extracted function and again in the calling function.  Thus, a pointer to the variable in the calling function will point to a different variable than the parameter/local in the extracted function.  So, an address-of operation performed prior to the call of, or inside, the extracted function may result in behavior changes if the memory address is accessed inside, or after the call to, the extracted function (respectively).

	- According to this spec, local variables are passed to the new function as-is; they are not changed to pointers.  So, large objects may be passed by value.

	- Another variant of Extract Function would be Extract Method.

	- Another variant of Extract Function extracts an expression rather than a sequence of statements.

	- An extension would be to identify "clones" of the selected statements (perhaps modulo renaming) and extract all clones to a single function at once.  Eclipse JDT does this completely syntactically (which is unsound).